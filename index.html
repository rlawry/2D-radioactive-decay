<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Radioactive Decay</title>

  <!-- Nuclide data (must define `nuclides`) -->
  <script src="nuclides.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root {
      --bg: #ffffff;
      --border: #000000;
      --accent: #00dac8;
      --danger: #782200;
      --purple: #bb00ff;
      --yellow: #ffd600;
      --text: #111111;
      --control-bg: #f0f0f0;
      --modal-backdrop: rgba(0, 0, 0, 0.4);
      --radius: 6px;
      --transition-fast: 0.2s;
      --font-main: Arial, Helvetica, sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: var(--font-main);
      font-size: 16px;
      font-weight: 400;
    }

    h1 {
      margin: 16px auto 8px;
      padding: 6px 12px;
      max-width: 900px;
      text-align: center;
      font-size: 24px;
      font-weight: 700;
      border-radius: var(--radius);
      box-shadow: inset 0 0 10px #1e90ff;
      background-color: #ffffff;
    }

    #total {
      max-width: 1000px;
      margin: 0 auto 24px;
      padding: 0 12px 24px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #canvas {
      position: relative;
      margin: 0;
      padding: 0;
      border: 1px solid var(--border);
      background-color: #aaaaaa;
      flex: 2 1 0;
      /* take about 2/3 of the row */
      max-width: 720px;
    }

    .canvas-footer {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      justify-content: center;
      align-items: center;
      padding: 6px 8px;
      font-size: 12px;
      background: #f7f7f7;
      border-top: 1px solid #cccccc;
    }

    .canvas-footer span {
      white-space: nowrap;
    }

    #simRow {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 8px;
      width: 100%;
      max-width: 960px;
    }

    /* Right-side nuclide panel */
    #nuclidePanel {
      flex: 1 1 0;
      /* about 1/3 of the row */
      max-width: 210px;
      background: #f9f9f9;
      border: 1px solid #cccccc;
      border-radius: var(--radius);
      padding: 6px 8px;
      font-size: 11px;
      line-height: 1.3;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
    }

    .nuclide-panel-header {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 4px;
      text-align: center;
    }

    .nuclide-panel-body {
      margin-bottom: 4px;
      max-height: 380px;
      /* scroll inside panel if long */
      overflow-y: auto;
    }

    .nuclide-panel-list {
      display: block;
    }

    .nuclide-panel-row {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      padding: 1px 0;
    }

    .nuclide-panel-name {
      flex: 1 1 auto;
    }

    .nuclide-panel-hl {
      white-space: nowrap;
      text-align: right;
    }

    .nuclide-panel-empty {
      font-style: italic;
      opacity: 0.8;
    }

    .nuclide-panel-footer {
      margin-top: 2px;
      font-size: 10px;
      text-align: center;
      opacity: 0.7;
    }

    #cv {
      display: block;
      width: 100%;
      /* keep aspect ratio consistent with intrinsic 960x480 => 2:1 */
      aspect-ratio: 2 / 1;
      height: auto;
      /* important: no fixed height */
      border: 1px solid #1e90ff;
    }

    .control-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      /* center horizontally */
      justify-content: center;
      padding: 10px 12px;
      background: var(--control-bg);
      border-bottom: 1px solid #cccccc;
      text-align: center;
    }

    .control-panel>div {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      justify-content: center;
      align-items: center;
    }

    .control-panel .pos1 {
      margin-right: 0;
      white-space: nowrap;
      position: static;
    }


    .control-panel input[type="number"] {
      margin-left: 6px;
      padding: 2px 4px;
      width: 90px;
      height: 22px;
      text-align: right;
      font-size: 12px;
    }

    button {
      border: none;
      background: #000000;
      color: #ffffff;
      text-align: center;
      width: 180px;
      font-size: 12px;
      font-weight: 700;
      padding: 8px 14px;
      margin: 4px 4px 0 0;
      text-transform: uppercase;
      border-radius: var(--radius);
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.9);
      display: inline-block;
      cursor: pointer;
      transition:
        background var(--transition-fast),
        transform var(--transition-fast),
        box-shadow var(--transition-fast),
        letter-spacing var(--transition-fast),
        color var(--transition-fast);
    }

    button:hover {
      background: #ffffff;
      color: #000000;
      letter-spacing: 1px;
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.25);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.8);
    }

    button.start {
      background: var(--accent);
      color: #000000;
    }

    button.reset {
      background: var(--danger);
    }

    button.nuclides {
      background: var(--yellow);
      color: #000000;
      width: 260px;
    }

    button.show-ideal {
      background: var(--purple);
      width: auto;
    }

    #graph {
      margin: 16px auto 0;
      width: 100%;
      max-width: 960px;
      height: 260px;
      /* chart height on desktop */
      border: 1px solid var(--border);
      background: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    #graphheader {
      padding: 4px 8px;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      background: rgba(0, 0, 0, 0.05);
    }

    #graph-cv {
      flex: 1 1 auto;
      display: block;
      width: 100%;
      height: 100%;
    }

    #graph .graph-button-wrapper {
      text-align: center;
      padding: 2px 0 4px;
    }

    @media (max-width: 900px) {
      #total {
        max-width: 100%;
        padding: 0 8px 16px;
      }

      #simRow {
        flex-direction: column;
        gap: 8px;
      }

      #canvas,
      #nuclidePanel {
        max-width: 100%;
        flex: 0 0 auto;
      }

      #graph {
        height: 220px;
        /* slightly shorter chart on phones */
      }

      button {
        width: auto;
        min-width: 120px;
      }

      .control-panel {
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>

  <h1>Radioactive Decay</h1>

  <div id="total">

    <div id="simRow">
      <div id="canvas">
        <div class="control-panel">
          <div>
            <span class="pos1">
              <input type="number" id="HalfLife" value="10">
              Half life (seconds)
            </span>
            <span class="pos1">
              <input type="number" id="gridX" value="20">
              Grid Size (horizontal)
            </span>
            <span class="pos1">
              <input type="number" id="gridY" value="20">
              Grid Size (vertical)
            </span>
            <span class="pos1">
              <label>
                <input type="checkbox" id="cloudChamber" checked>
                Cloud chamber (show tracks)
              </label>
            </span>
          </div>
          <div>
            <div>
              <button id="bu2" class="start">Start</button>
              <button id="bu1" class="reset">Reset</button>
            </div>
          </div>
        </div>

        <canvas id="cv" width="960" height="480">
          This browser doesn't support HTML5 canvas!
        </canvas>
        <div id="canvas-footer" class="canvas-footer">
          <span id="footer-parents"></span>
          <span id="footer-daughters"></span>
          <span id="footer-time"></span>
          <span id="footer-decayed-segment"></span>
        </div>
      </div>

      <!-- Right-side panel -->
      <aside id="nuclidePanel" aria-label="Isotopes with similar half-life">
        <div class="nuclide-panel-header">Isotopes with Similar Half-Life</div>
        <div class="nuclide-panel-body">
          <div class="nuclide-panel-list">
            <p class="nuclide-panel-empty">
              Click “Display Isotopes with Similar Half Life” to load the list.
            </p>
          </div>
        </div>
        <div class="nuclide-panel-footer">
          Uses the current half-life value (seconds). Data from NuDat 2.8 (NNDC) <a href="https://nucleus.iaea.org/"
            target="_blank">here</a>.
        </div>
      </aside>
    </div>


    <div id="graph">
      <div id="graphheader">The Graph</div>
      <canvas id="graph-cv" width="597" height="220">
        This browser doesn't support HTML5 canvas!
      </canvas>
      <div class="graph-button-wrapper">
        <button id="bu3" class="show-ideal">Show Ideal Decay Plot</button>
      </div>
    </div>
  </div>

  <script>
    var colorBackground = "rgba(50,50,50,1)";
    var colorActive = "#ff0000";
    var colorGradActive;
    var colorDecayed = "#000000";
    var colorTime = "#0000ff";

    var showCloudChamber = true;  // controls trail rendering only

    var prevHalfLife = null;   // for palette changes

    var FONT1 = "normal normal bold 12px sans-serif";
    var halfLife = 20;
    var AtomTotal = 400;
    var xAtoms = 20;
    var yAtoms = 20;
    var atomRadius = 5;
    var graphXPos = 50, graphYPos = 0;
    var graphXIncrement = 40;
    var graphYIncrement = 100;
    var textXPos = 10, textYPos = 20;
    var graphXLength = 420;
    var graphTotalHalfLives = Math.floor(graphXLength / graphXIncrement);
    var atomXPos = 50;
    var atomYPos = 30;
    var timeText = "None.";
    var timeElapsed = 0;
    var spacing = 15;
    var graphScale = 1.2;

    var graphChart = null;   // Chart.js instance

    var canvas, ctx, graphCanvas, graphCtx;
    var bu1, bu2, bu3;
    var on;
    var t0;
    var timer;
    var timeVariable;
    var timeDecay;
    var decayed;
    var number;
    var xyDiagram;

    var text01 = "Reset";
    var text02 = ["Start", "Pause and Plot", "Resume"];
    var text03 = "Show Ideal Decay Plot";

    var text04 = "Half Lives:";
    var text05 = "Not yet decayed:";
    var text06 = "Already decayed:";
    var text07 = ["nuclei", "nucleus", "nuclei", "nuclei"];
    var text08 = "Actual time elapsed:";
    var text09 = ["milliseconds", "seconds", "minutes", "hours", "days", "weeks", "months", "years"];

    var decimalSeparator = ".";
    var symbolHalfLife = "T½";
    var symbolQuotient = "Parent/Daughter";

    var decayRunning = false;   // controls radioactive decay only
    var loopRunning = false;   // controls whether RAF loop is active
    var rafId = null;
    var lastNow = 0;

    var atomsBuffer = null;
    var atomsCtx = null;

    var decaySchedule = null;
    var nextDecayIndex = 0;

    var particles = [];
    var animFrameId = null;

    var denseMode = false;  // true when atoms are effectively pixels

    var geigerPool = [];
    var geigerPoolIndex = 0;
    var GEIGER_POOL_SIZE = 8;  // number of overlapping clicks allowed

    var footerParentsEl, footerDaughtersEl, footerTimeEl, footerDecayedEl;

    // tracking since last Start/Resume (segment)
    var segmentStartTimeVar = 0;        // timeVariable at segment start
    var segmentStartDecayedCount = 0;   // decayed count at segment start
    var lastSegmentElapsed = 0;         // last computed elapsed (used while paused)

    function getNucleusPosition(i) {
      return {
        x: atomXPos + spacing * (i % xAtoms),
        y: atomYPos + spacing * Math.floor(i / xAtoms)
      };
    }

    const ACCENT_RGBA = "rgba(0,218,200,1)";

    function spawnParticle(x, y) {
      //if (denseMode) return;
      const angle = Math.random() * 2 * Math.PI;
      const speed = 3500 + Math.random() * 300;  // keep your high energy
      const life = 2 + Math.random() * 1;       // uniform fade window
      const length = 550 + Math.random() * 200;   // track length

      const dx = Math.cos(angle), dy = Math.sin(angle);

      // Precompute polyline at fixed spacing -> smooth, uniform density
      const spacing = 6; // px between vertices
      const n = Math.max(2, Math.ceil(length / spacing));
      const points = new Array(n);
      for (let i = 0; i < n; i++) {
        const s = i * spacing;
        points[i] = { x: x + dx * s, y: y + dy * s };
      }

      // Precompute shimmer specks anchored to the line (2 per vertex)
      const theta = Math.atan2(dy, dx) + Math.PI / 2;
      const specks = [];
      for (let i = 0; i < n; i++) {
        const base = points[i];
        const jitter = (Math.random() - 0.5) * 4; // ±2 px band
        const sx = base.x + Math.cos(theta) * jitter;
        const sy = base.y + Math.sin(theta) * jitter;
        const at = i * spacing; // distance along track where speck becomes visible
        specks.push({ x: sx, y: sy, r: 0.9 + Math.random() * 1.1, at });
        specks.push({
          x: sx + (Math.random() - 0.5),
          y: sy + (Math.random() - 0.5), r: 0.7 + Math.random() * 0.9, at
        });
      }

      particles.push({
        x0: x, y0: y, dx, dy,
        speed, length,
        age: 0, life, maxLife: life,
        spacing, points, specks
      });
    }

    function updateParticles(dt) {
      if (dt <= 0) return;

      var w = canvas.width, h = canvas.height, margin = 24;

      for (var i = particles.length - 1; i >= 0; i--) {
        var p = particles[i];
        p.age += dt;
        p.life -= dt;

        if (p.life <= 0) { particles.splice(i, 1); continue; }

        // current tip position along the ray
        var tipLen = Math.min(p.speed * p.age, p.length);
        var tx = p.x0 + p.dx * tipLen;
        var ty = p.y0 + p.dy * tipLen;

        // If the track is complete OR the head is well off-screen, drop it
        if (tipLen >= p.length || tx < -margin || tx > w + margin || ty < -margin || ty > h + margin) {
          particles.splice(i, 1);
        }
      }
    }

    function prand(seed) {
      var x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    function renderParticles() {
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        var lifeFactor = p.life / p.maxLife;
        if (lifeFactor <= 0) continue;

        var currentLen = Math.min(p.speed * p.age, p.length);
        if (currentLen <= 0) continue;

        var alphaTrack = Math.max(0, Math.min(1, lifeFactor)) * 0.9;

        if (showCloudChamber) {
          var perp = Math.atan2(p.dy, p.dx) + Math.PI / 2;

          // dynamically reduce resolution when there are many particles
          var baseSegments = 60;
          var densityFactor = 1 + (particles.length / 30);
          var segments = Math.max(12, Math.floor(baseSegments / densityFactor));

          var step = currentLen / segments;

          for (var s = 0; s <= currentLen; s += step) {
            var baseX = p.x0 + p.dx * s;
            var baseY = p.y0 + p.dy * s;

            var jitterMag = 2 + 2 * Math.random();
            var jitter = (Math.random() - 0.5) * 2 * jitterMag;

            var cx = baseX + Math.cos(perp) * jitter;
            var cy = baseY + Math.sin(perp) * jitter;

            // 2 specks per sample
            for (var k = 0; k < 2; k++) {
              var r = 1.0 + 1.0 * Math.random();

              ctx.beginPath();
              ctx.fillStyle = "rgba(0,218,200," + alphaTrack + ")";
              ctx.arc(
                cx + (Math.random() - 0.5) * 0.8,
                cy + (Math.random() - 0.5) * 0.8,
                r,
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }

        // bright head
        var tipX = p.x0 + p.dx * currentLen;
        var tipY = p.y0 + p.dy * currentLen;

        ctx.beginPath();
        ctx.fillStyle = "rgba(255,255,255," + alphaTrack + ")";
        ctx.arc(tipX, tipY, 2.6, 0, 2 * Math.PI);
        ctx.fill();
      }
    }


    function segmentOffscreen(x1, y1, x2, y2, m, W, H) {
      const left = Math.max(x1, x2) < -m;
      const right = Math.min(x1, x2) > W + m;
      const above = Math.max(y1, y2) < -m;
      const below = Math.min(y1, y2) > H + m;
      return left || right || above || below;
    }

    function renderAtomsAndParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (atomsBuffer) {
        ctx.drawImage(atomsBuffer, 0, 0);
      } else {
        // fallback (should rarely happen)
        ctx.fillStyle = colorBackground;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i < AtomTotal; i++) {
          var c = decayed[i] ? colorDecayed : colorActive;
          drawNucleus(i, c);
        }
      }

      renderParticles();
    }

    function getElement(id, text) {
      var e = document.getElementById(id);
      if (text) e.innerHTML = text;
      return e;
    }

    function initHalfLifeLogControl(input) {
      if (!input) return;

      var MIN_HALF_LIFE = 1e-23;   // seconds (choose whatever makes sense)
      var MAX_HALF_LIFE = 1e23;   // upper bound to avoid crazy numbers
      var LOG_STEP = 0.1;        // ~10^0.15 ≈ 1.41× per step (tweak to taste)

      function parseHalfLife() {
        var v = parseFloat(input.value);
        if (!Number.isFinite(v) || v <= 0) v = 10; // sane default
        return v;
      }

      function formatHalfLife(v) {
        // clamp to positive range
        if (v < MIN_HALF_LIFE) v = MIN_HALF_LIFE;
        if (v > MAX_HALF_LIFE) v = MAX_HALF_LIFE;

        // choose decimal places based on order of magnitude
        var log10v = Math.log(v) / Math.LN10;
        var decimals = 0;
        if (log10v < -1) decimals = 4;
        else if (log10v < 0) decimals = 3;
        else if (log10v < 2) decimals = 2;
        else decimals = 0;

        return v.toFixed(decimals);
      }

      function stepHalfLife(direction) {
        // direction: +1 for up / scroll up, -1 for down / scroll down
        var current = parseHalfLife();
        var log10v = Math.log(current) / Math.LN10;
        log10v += LOG_STEP * direction;
        var next = Math.pow(10, log10v);

        input.value = formatHalfLife(next);

        // keep everything in sync with the rest of your app
        updateNuclidePanel();
        reactionReset();  // rebuild atoms & decay schedule with new half-life
      }

      // Mouse wheel → log steps
      input.addEventListener("wheel", function (event) {
        event.preventDefault(); // avoid the default linear step / page scroll

        if (event.deltaY < 0) {
          // scroll up → increase half-life
          stepHalfLife(+1);
        } else if (event.deltaY > 0) {
          // scroll down → decrease half-life
          stepHalfLife(-1);
        }
      }, { passive: false });

      // Arrow keys → same log steps
      input.addEventListener("keydown", function (event) {
        if (event.key === "ArrowUp") {
          event.preventDefault();
          stepHalfLife(+1);
        } else if (event.key === "ArrowDown") {
          event.preventDefault();
          stepHalfLife(-1);
        }
      });
    }

    function addWheelIncrement(input, step, min, max) {
      if (!input) return;
      input.addEventListener("wheel", function (event) {
        event.preventDefault();

        var value = parseInt(input.value, 10);
        if (!Number.isFinite(value)) value = min;

        if (event.deltaY < 0) {
          value += step;              // scroll up -> increase
        } else if (event.deltaY > 0) {
          value -= step;              // scroll down -> decrease
        }

        if (value < min) value = min;
        if (max && value > max) value = max;

        input.value = value;

        // Rebuild atoms and graph with new grid
        reactionReset();
      }, { passive: false });
    }

    function initGeiger() {
      var base = document.getElementById("geigerSound");
      if (!base) return;

      geigerPool = [];
      geigerPoolIndex = 0;

      for (var i = 0; i < GEIGER_POOL_SIZE; i++) {
        var clone = base.cloneNode();
        clone.removeAttribute("id");     // avoid duplicate IDs
        clone.volume = 0.6;              // tweak volume if needed
        document.body.appendChild(clone);
        geigerPool.push(clone);
      }
    }

    function playGeiger() {
      if (!geigerPool.length) return;

      var a = geigerPool[geigerPoolIndex];
      geigerPoolIndex = (geigerPoolIndex + 1) % geigerPool.length;

      try {
        a.currentTime = 0;
        a.play();
      } catch (e) {
        // ignore play() failures (e.g. before user interaction)
      }
    }

    function start() {
      canvas = getElement("cv");
      graphCanvas = getElement("graph-cv");
      ctx = canvas.getContext("2d");
      graphCtx = graphCanvas.getContext("2d");
      textXPos = 230;

      bu1 = getElement("bu1", text01);
      bu2 = getElement("bu2");
      bu3 = getElement("bu3", text03);

      setButton2State(0);

      // wheel on grid inputs (already there)
      addWheelIncrement(document.getElementById("gridX"), 1, 1, 300);
      addWheelIncrement(document.getElementById("gridY"), 1, 1, 300);

      // NEW: log-style wheel + arrow keys for half-life
      var halfLifeInput = document.getElementById("HalfLife");
      initHalfLifeLogControl(halfLifeInput);

      initGeiger();

      footerParentsEl = document.getElementById("footer-parents");
      footerDaughtersEl = document.getElementById("footer-daughters");
      footerTimeEl = document.getElementById("footer-time");
      footerDecayedEl = document.getElementById("footer-decayed-segment");

      reset();
      paintAtoms();

      // after first reset, initialize segment tracking + footer
      resetSegmentTracking();
      updateFooter();

      bu1.onclick = reactionReset;
      bu2.onclick = reactionStart;
      bu3.onclick = reactionDiagram;

      var cc = getElement("cloudChamber");
      if (cc) {
        showCloudChamber = cc.checked;
        cc.addEventListener("change", function () {
          showCloudChamber = cc.checked;
          renderAtomsAndParticles();
        });
      }

      // nuclide panel wiring (you already have this)
      if (halfLifeInput) {
        halfLifeInput.addEventListener("input", updateNuclidePanel);
        halfLifeInput.addEventListener("change", updateNuclidePanel);
      }
    }

    function resetSegmentTracking() {
      // called after full reset
      segmentStartTimeVar = timeVariable;                 // usually 0
      segmentStartDecayedCount = AtomTotal - number;      // usually 0
      lastSegmentElapsed = 0;
    }

    function startSegment() {
      // called every time we go into "running" state (Start or Resume)
      segmentStartTimeVar = timeVariable;
      segmentStartDecayedCount = AtomTotal - number;
      lastSegmentElapsed = 0;
    }

    function updateFooter() {
      if (!footerParentsEl) return;

      var parents = number;
      var daughters = AtomTotal - number;
      var decayedTotal = daughters;

      var elapsed;
      if (decayRunning) {
        elapsed = timeVariable - segmentStartTimeVar;
        if (elapsed < 0) elapsed = 0;
        lastSegmentElapsed = elapsed;
      } else {
        // when paused, keep showing last value
        elapsed = lastSegmentElapsed;
      }

      var decayedSinceSegment = decayedTotal - segmentStartDecayedCount;
      if (decayedSinceSegment < 0) decayedSinceSegment = 0;

      footerParentsEl.textContent =
        "# Parent Particles Present: " + parents;

      footerDaughtersEl.textContent =
        "# Daughter Particles Present: " + daughters;

      footerTimeEl.textContent =
        "Time Since Pause/Start: " + elapsed.toFixed(2) + " s";

      footerDecayedEl.textContent =
        "Number of Particles Decayed Since Pause/Start: " + decayedSinceSegment;
    }

    function initGraphChart() {
      var gCanvas = document.getElementById("graph-cv");
      if (!gCanvas || typeof Chart === "undefined") return;

      graphChart = new Chart(gCanvas, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Actual decay (Parent/Daughter)",
              data: [],            // filled by savePoint()
              showLine: false,
              pointRadius: 4
            },
            {
              label: "Ideal decay",
              data: [],            // filled on first button click
              type: "line",
              showLine: true,
              pointRadius: 0,
              borderWidth: 2,
              borderDash: [4, 3],
              hidden: true         // start hidden
            }
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 10,
              right: 16,
              bottom: 30,   // room for x-axis label and ticks
              left: 16
            }
          },
          scales: {
            x: {
              type: "linear",
              title: {
                display: true,
                text: "Time (half-lives, T)",
                font: { size: 12 }
              },
              ticks: {
                font: { size: 11 }
              },
              min: 0,
              max: graphTotalHalfLives
            },
            y: {
              type: "linear",
              title: {
                display: true,
                text: "Fraction remaining (Parent/Daughter)",
                font: { size: 12 }
              },
              ticks: {
                font: { size: 11 }
              },
              min: 0,
              max: 1
            }
          },
          plugins: {
            legend: {
              position: "top",
              labels: {
                font: { size: 11 }
              }
            }
          }
        }
      });
    }

    function setButton2State(st) {
      bu2.state = st;
      bu2.innerHTML = text02[st];
      bu2.classList.toggle("start", st === 0 || st === 2);
    }

    function switchButton2() {
      var st = bu2.state;
      if (st === 0) st = 1;
      else st = 3 - st;
      setButton2State(st);
    }

    function reactionReset() {
      setButton2State(0);
      decayRunning = false;
      stopLoop();
      reset();
      paintAtoms();

      resetSegmentTracking();
      updateFooter();

      updateNuclidePanel();
    }

    function reactionStart() {
      // toggle button state: 0->1 (start), 1->2 (pause), 2->1 (resume)
      switchButton2();

      if (bu2.state === 1) {          // Start/Resume
        startSegment();               // NEW: start counting from here
        decayRunning = true;
        ensureLoop();
      } else if (bu2.state === 2) {   // Pause
        decayRunning = false;
        savePoint();
        ensureLoop();
      }
    }

    function ensureLoop() {
      if (!loopRunning) {
        loopRunning = true;
        lastNow = performance.now();
        rafId = requestAnimationFrame(loopStep);
      }
    }

    function stopLoop() {
      loopRunning = false;
      if (rafId != null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    }

    function loopStep(now) {
      if (!loopRunning) return;

      var dt = (now - lastNow) / 1000;
      lastNow = now;
      if (dt < 0) dt = 0;
      if (dt > 0.1) dt = 0.1;   // clamp tab-jump spikes

      paintSimulation(dt);      // advance particles every frame; decay only if running

      // Auto-stop when nothing to animate
      if (!decayRunning && particles.length === 0) {
        stopLoop();
        return;
      }
      rafId = requestAnimationFrame(loopStep);
    }

    function reactionDiagram() {
      if (!graphChart) return;

      var idealDataset = graphChart.data.datasets[1];

      // Populate ideal decay if empty
      if (!idealDataset.data || idealDataset.data.length === 0) {
        var pts = [];
        for (var x = 0; x <= graphTotalHalfLives; x += 0.05) {
          pts.push({ x: x, y: Math.pow(2, -x) });
        }
        idealDataset.data = pts;
      }

      // Toggle visibility
      idealDataset.hidden = !idealDataset.hidden;
      bu3.textContent = idealDataset.hidden
        ? "Show Ideal Decay Plot"
        : "Hide Ideal Decay Plot";

      graphChart.update();
    }

    function animationStep(now) {
      if (!on) return;

      var dt = (now - t0) / 1000;  // ms -> s
      t0 = now;

      // Clamp dt to avoid jumps if tab was inactive
      if (dt < 0) dt = 0;
      if (dt > 0.1) dt = 0.1;

      paintSimulation(dt);
      animFrameId = requestAnimationFrame(animationStep);
    }

    function savePoint() {
      if (!graphChart) return;

      // x-axis: time in units of half-life (T)
      var tHalfLives = halfLife > 0 ? timeVariable / halfLife : 0;
      if (tHalfLives < 0) tHalfLives = 0;
      if (tHalfLives > graphTotalHalfLives) return;

      // y-axis: fraction remaining N/N0
      var frac = AtomTotal > 0 ? number / AtomTotal : 0;

      graphChart.data.datasets[0].data.push({ x: tHalfLives, y: frac });
      graphChart.update();
    }

    function setRandomPalette() {
      // base hue 0–359
      var baseHue = Math.floor(Math.random() * 360);

      // active: bright
      var activeHue = baseHue;
      // decayed: opposite hue, darker
      var decayedHue = (baseHue + 180) % 360;

      colorActive = "hsl(" + activeHue + ", 90%, 55%)";
      colorDecayed = "hsl(" + decayedHue + ", 90%, 30%)";
    }

    function reset() {
      var halfLifeVal = parseFloat(document.getElementById("HalfLife").value);
      var gridXVal = parseInt(document.getElementById("gridX").value, 10);
      var gridYVal = parseInt(document.getElementById("gridY").value, 10);

      halfLife = (Number.isFinite(halfLifeVal) && halfLifeVal > 0) ? halfLifeVal : 10;
      xAtoms = (Number.isFinite(gridXVal) && gridXVal > 0) ? gridXVal : 20;
      yAtoms = (Number.isFinite(gridYVal) && gridYVal > 0) ? gridYVal : 20;

      if (prevHalfLife === null || halfLife !== prevHalfLife) {
        setRandomPalette();
        prevHalfLife = halfLife;
      }

      // === NEW: compute spacing & radius to fit grid into fixed canvas ===
      var margin = 40; // px padding on each side
      var widthAvail = Math.max(10, canvas.width - 2 * margin);
      var heightAvail = Math.max(10, canvas.height - 2 * margin);

      var spacingX = (xAtoms > 1) ? widthAvail / (xAtoms - 1) : widthAvail;
      var spacingY = (yAtoms > 1) ? heightAvail / (yAtoms - 1) : heightAvail;

      // uniform cell size so atoms keep their shape
      spacing = Math.min(spacingX, spacingY, 30);

      atomXPos = (canvas.width - (xAtoms - 1) * spacing) / 2;
      atomYPos = (canvas.height - (yAtoms - 1) * spacing) / 2;

      AtomTotal = xAtoms * yAtoms;

      // radius as a fraction of spacing
      atomRadius = Math.max(1, Math.min(spacing * 0.35, 10));

      denseMode = (spacing < 3 || atomRadius <= 1.5);

      // === existing decay / schedule / buffer code follows ===
      var f = -halfLife / Math.LN2;
      timeVariable = 0;
      number = AtomTotal;
      particles = [];
      timeDecay = new Array(AtomTotal);
      decayed = new Array(AtomTotal);

      for (var i = 0; i < AtomTotal; i++) {
        var r;
        do {
          r = Math.random();
        } while (r === 0 || r === 1);
        timeDecay[i] = f * Math.log(r);
        decayed[i] = false;
      }

      decaySchedule = new Array(AtomTotal);
      for (var j = 0; j < AtomTotal; j++) {
        decaySchedule[j] = { t: timeDecay[j], idx: j };
      }
      decaySchedule.sort(function (a, b) { return a.t - b.t; });
      nextDecayIndex = 0;

      if (graphChart) {
        graphChart.data.datasets[0].data = [];
        graphChart.update();
      }

      if (!atomsBuffer ||
        atomsBuffer.width !== canvas.width ||
        atomsBuffer.height !== canvas.height) {

        atomsBuffer = document.createElement("canvas");
        atomsBuffer.width = canvas.width;
        atomsBuffer.height = canvas.height;
        atomsCtx = atomsBuffer.getContext("2d");
      }

      atomsCtx.fillStyle = colorBackground;
      atomsCtx.fillRect(0, 0, canvas.width, canvas.height);
      for (var k = 0; k < AtomTotal; k++) {
        drawNucleusOn(atomsCtx, k, colorActive);
      }

      savePoint();
    }

    function newPath() {
      ctx.beginPath();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1;
    }

    function line(x1, y1, x2, y2, c) {
      graphCtx.beginPath();
      if (c) graphCtx.strokeStyle = c;
      graphCtx.moveTo(x1, y1);
      graphCtx.lineTo(x2, y2);
      graphCtx.stroke();
      graphCtx.closePath();
    }

    function arrow(x1, y1, x2, y2, w) {
      graphCtx.strokeStyle = "black";
      graphCtx.fillStyle = "black";
      if (!w) w = 1;
      var dx = x2 - x1, dy = y2 - y1;
      var length = Math.sqrt(dx * dx + dy * dy);
      if (length === 0) return;
      dx /= length; dy /= length;
      var s = 2.5 * w + 7.5;
      var xSp = x2 - s * dx, ySp = y2 - s * dy;
      var h = 0.5 * w + 3.5;
      var xSp1 = xSp - h * dy, ySp1 = ySp + h * dx;
      var xSp2 = xSp + h * dy, ySp2 = ySp - h * dx;
      xSp = x2 - 0.6 * s * dx; ySp = y2 - 0.6 * s * dy;

      graphCtx.beginPath();
      graphCtx.lineWidth = w;
      graphCtx.moveTo(x1, y1);
      if (length < 5) graphCtx.lineTo(x2, y2);
      else graphCtx.lineTo(xSp, ySp);
      graphCtx.stroke();

      if (length < 5) return;
      graphCtx.beginPath();
      graphCtx.lineWidth = 1;
      graphCtx.moveTo(xSp, ySp);
      graphCtx.lineTo(xSp1, ySp1);
      graphCtx.lineTo(x2, y2);
      graphCtx.lineTo(xSp2, ySp2);
      graphCtx.closePath();
      graphCtx.fill();
    }

    function circle(x, y, r, c) {
      if (c) ctx.fillStyle = c;
      ctx.strokeStyle = "black";
      newPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI, true);
      ctx.fill();
      newPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI, true);
      ctx.stroke();
    }

    function writePercent(s, x, y) {
      s = s.replace(".", decimalSeparator);
      write(s, x - 17, y, "right");
      write("%", x - 15, y, "left");
    }

    function writeTextIndex(s, x, y) {
      var s1 = s;
      var i = s1.indexOf("_");
      if (i >= 0) s1 = s.substring(0, i);
      var s2 = "";
      if (i >= 0) s2 = s.substring(i + 1);
      var l1 = graphCtx.measureText(s1).width;
      write(s1, x, y, "left");
      if (i >= 0) write(s2, x + l1, y + 5);
    }

    function drawGraph() {
      graphCanvas = getElement("graph-cv");
      graphXPos = 50;
      graphYPos = 150;

      graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
      graphCtx.beginPath();
      graphCtx.textAlign = "center";
      graphCtx.strokeStyle = "black";

      arrow(graphXPos - 10, graphYPos, graphXPos + graphXLength * graphScale, graphYPos);
      graphCtx.fillText("Time", graphXPos + 215, graphYPos + 33);

      for (var i = 1; i <= graphTotalHalfLives; i++) {
        var xT = graphXPos + i * graphXIncrement;
        line(xT, graphYPos + 3, xT, graphYPos - 3);
        var s = (i > 1 ? "" + i + "T" : "T");
        graphCtx.fillText(s, xT, graphYPos + 15);
      }

      arrow(graphXPos, graphYPos + 10, graphXPos, graphYPos - 125 * graphScale);

      for (var k = 0; k <= 4; k++) {
        var y0 = graphYPos - graphYIncrement * Math.pow(2, -k);
        line(graphXPos - 3, y0, graphXPos + 3, y0, "black");
      }

      writeTextIndex(symbolQuotient, graphXPos - 30, graphYPos - 115);
      writePercent("100", graphXPos, graphYPos - 95);
      writePercent("50", graphXPos, graphYPos - 45);
      writePercent("25", graphXPos, graphYPos - 20);
      writePercent("12.5", graphXPos, graphYPos - 8);
    }

    function drawNucleusOn(targetCtx, i, c) {
      var pos = getNucleusPosition(i);
      var x = pos.x;
      var y = pos.y;

      // Dense mode: treat atoms as pixels
      if (denseMode) {
        targetCtx.fillStyle = c;
        // 1x1 pixel (or 2x2 if you want)
        var px = Math.round(x);
        var py = Math.round(y);
        targetCtx.fillRect(px, py, 1, 1);
        return;
      }

      // Normal mode: circle / square
      if (c === colorDecayed) {
        targetCtx.fillStyle = colorDecayed;
        targetCtx.fillRect(x - atomRadius, y - atomRadius, atomRadius * 2, atomRadius * 2);
      } else {
        targetCtx.fillStyle = colorActive;
        targetCtx.beginPath();
        targetCtx.strokeStyle = "black";
        targetCtx.arc(x, y, atomRadius, 0, 2 * Math.PI);
        targetCtx.fill();
        targetCtx.stroke();
      }
    }


    function drawNucleus(i, c) {
      drawNucleusOn(ctx, i, c);
    }

    function paintAtoms() {
      renderAtomsAndParticles();
    }

    function drawDecayLine() {
      graphCtx.beginPath();
      graphCtx.strokeStyle = "blue";

      var xx = graphXPos;
      var yy = graphYPos - graphYIncrement;
      graphCtx.moveTo(xx, yy);

      while (xx < graphXPos + 300) {
        xx++;
        yy = graphYPos - graphYIncrement *
          Math.exp(-(xx - graphXPos) / graphXIncrement * Math.LN2);
        graphCtx.lineTo(xx, yy);
      }
      graphCtx.stroke();
      graphCtx.closePath();
      graphCtx.strokeStyle = "black";
    }

    function write(s, x, y, a) {
      if (a) graphCtx.textAlign = a;
      graphCtx.fillText(s, x, y);
    }

    function textNuclei(n) {
      if (n === 0) return text07[0];
      if (n === 1) return text07[1];
      if (n === 2) return text07[2];
      return text07[3];
    }

    function writeValues() {
      graphCtx.fillStyle = colorBackground;
      graphCtx.fillRect(textXPos, textYPos, 280, 77);

      var x1 = textXPos + 190;
      var x2 = textXPos + 200;
      var y1 = textYPos + 10;
      var y2 = textYPos + 30;
      var y3 = textYPos + 50;
      var y4 = textYPos + 70;

      graphCtx.fillStyle = colorTime;

      write(text04, textXPos, y1, "left");
      var s = Number(timeVariable / halfLife).toFixed(2);
      var s1 = timeVariable;
      s = s.replace(".", decimalSeparator);
      write(s, x1, y1, "right");
      write(symbolHalfLife, x2, y1, "left");

      graphCtx.fillStyle = colorActive;
      write(text05, textXPos, y2);
      write(String(number), x1, y2, "right");
      write(textNuclei(number), x2, y2, "left");

      graphCtx.fillStyle = colorDecayed;
      write(text06, textXPos, y3);
      var nd = AtomTotal - number;
      write(String(nd), x1, y3, "right");
      write(textNuclei(nd), x2, y3, "left");

      setTimeText(s1);
      graphCtx.fillStyle = colorTime;
      write(text08, textXPos, y4);
      var sElapsed = Number(timeElapsed).toFixed(2)
        .replace(".", decimalSeparator);
      write(sElapsed, x1, y4, "right");
      write(timeText, x2, y4, "left");
      graphCtx.fillStyle = "black";
    }

    function setTimeText(timeNum) {
      if (timeNum < 1) {
        timeText = text09[0];
        timeElapsed = timeNum;
      } else if (timeNum < 60) {
        timeText = text09[1];
        timeElapsed = timeNum;
      } else if (timeNum < 3600) {
        timeText = text09[2];
        timeElapsed = timeNum / 60;
      } else if (timeNum < 86400) {
        timeText = text09[3];
        timeElapsed = timeNum / 3600;
      } else if (timeNum < 604800) {
        timeText = text09[4];
        timeElapsed = timeNum / 86400;
      } else if (timeNum <= 2449440) {
        timeText = text09[5];
        timeElapsed = timeNum / 604800;
      } else if (timeNum <= 31536000) {
        timeText = text09[6];
        timeElapsed = timeNum / 2449440;
      } else {
        timeText = text09[7];
        timeElapsed = timeNum / 31536000;
      }
    }

    function paintSimulation(dt) {
      dt = dt || 0;

      // Spawn decays only when decay is running
      if (decayRunning && dt > 0) {
        timeVariable += dt;

        // emit all atoms whose decay time has passed
        while (nextDecayIndex < AtomTotal &&
          timeVariable >= decaySchedule[nextDecayIndex].t) {

          var atomIdx = decaySchedule[nextDecayIndex].idx;

          if (!decayed[atomIdx]) {
            decayed[atomIdx] = true;
            number--;

            var pos = getNucleusPosition(atomIdx);
            spawnParticle(pos.x, pos.y);

            // update cached nuclei drawing (see section 2)
            if (atomsCtx) {
              drawNucleusOn(atomsCtx, atomIdx, colorDecayed);
            }
            playGeiger();
          }

          nextDecayIndex++;
        }
      }

      updateParticles(dt);
      renderAtomsAndParticles();
      updateFooter();
    }

    document.addEventListener("DOMContentLoaded", function () {
      start();
      initGraphChart();
      updateNuclidePanel();
    }, false);

    // Isotope side panel (no modal)
    // Isotope side panel (no modal)
    function updateNuclidePanel() {
      var panel = document.getElementById("nuclidePanel");
      if (!panel) return;

      var listEl = panel.querySelector(".nuclide-panel-list");
      if (!listEl) return;

      var input = document.getElementById("HalfLife");
      var halfLifeVal = parseFloat(input && input.value);

      if (!Number.isFinite(halfLifeVal) || halfLifeVal <= 0) {
        listEl.innerHTML =
          '<p class="nuclide-panel-empty">Enter a positive half-life to see matching isotopes.</p>';
        return;
      }

      var matches = [];
      if (typeof nuclides === "object" && Array.isArray(nuclides.nuclides)) {
        var logTarget = Math.log(halfLifeVal);

        for (var i = 0; i < nuclides.nuclides.length; i++) {
          var nuc = nuclides.nuclides[i];
          var nHL = nuc["half-life"];
          if (!nHL || nHL <= 0) continue;

          // Within ±1 order of magnitude in log-space
          if (Math.abs(Math.log(nHL) - logTarget) <= 1) {
            matches.push(nuc);
          }
        }

        // Sort by half-life for readability
        matches.sort(function (a, b) {
          return a["half-life"] - b["half-life"];
        });
      }

      if (!matches.length) {
        listEl.innerHTML =
          '<p class="nuclide-panel-empty">No isotopes in the dataset within one order of magnitude.</p>';
        return;
      }

      var html = "";
      for (var j = 0; j < matches.length; j++) {
        var n = matches[j];
        html +=
          '<div class="nuclide-panel-row">' +
          '<span class="nuclide-panel-name">' + n.name + '</span>' +
          '<span class="nuclide-panel-hl">' +
          numberWithCommas(n["half-life"]) + ' s</span>' +
          '</div>';
      }
      listEl.innerHTML = html;
    }


    // Wire the button to update the side panel
    var bu4 = document.getElementById("bu4");
    if (bu4) {
      bu4.addEventListener("click", updateNuclidePanel);
    }

    function numberWithCommas(x) {
      x = Number(x);
      if (!Number.isFinite(x)) return "";
      if (x >= 1) {
        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      if (x > 0 && x < 1) {
        var parts = x.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, " ");
        return parts.join(".");
      }
      return x.toString();
    }
  </script>
  <audio id="geigerSound" src="geiger.mp3" preload="auto"></audio>
</body>

</html>