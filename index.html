<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Radioactive Decay</title>

  <!-- Nuclide data (must define `nuclides`) -->
  <script src="nuclides.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root {
      --bg: #ffffff;
      --border: #000000;
      --accent: #00dac8;
      --danger: #782200;
      --purple: #bb00ff;
      --yellow: #ffd600;
      --text: #111111;
      --control-bg: #f0f0f0;
      --modal-backdrop: rgba(0, 0, 0, 0.4);
      --radius: 6px;
      --transition-fast: 0.2s;
      --font-main: Arial, Helvetica, sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: var(--font-main);
      font-size: 16px;
      font-weight: 400;
    }

    h1 {
      margin: 16px auto 8px;
      padding: 6px 12px;
      max-width: 900px;
      text-align: center;
      font-size: 24px;
      font-weight: 700;
      border-radius: var(--radius);
      box-shadow: inset 0 0 10px #1e90ff;
      background-color: #ffffff;
    }

    #total {
      max-width: 1000px;
      margin: 0 auto 24px;
      padding: 0 12px 24px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #canvas {
      position: relative;
      margin: 0;
      padding: 0;
      border: 1px solid var(--border);
      background-color: #aaaaaa;
      width: 100%;
      max-width: 960px;
    }

    #simRow {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 8px;
      width: 100%;
      max-width: 960px;
    }

    /* Let the canvas area flex next to the panel */
    #canvas {
      flex: 1 1 auto;
      max-width: none;
    }

    /* Right-side nuclide panel */
    #nuclidePanel {
      flex: 0 0 220px;
      background: #f9f9f9;
      border: 1px solid #cccccc;
      border-radius: var(--radius);
      padding: 6px 8px;
      font-size: 11px;
      line-height: 1.3;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
    }

    .nuclide-panel-header {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 4px;
      text-align: center;
    }

    .nuclide-panel-body {
      margin-bottom: 4px;
      max-height: 430px;
      /* scrollable area */
      overflow-y: auto;
      /* scroll if list is long */
    }

    .nuclide-panel-list {
      display: block;
    }

    .nuclide-panel-row {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      padding: 1px 0;
    }

    .nuclide-panel-name {
      flex: 1 1 auto;
    }

    .nuclide-panel-hl {
      white-space: nowrap;
      text-align: right;
    }

    .nuclide-panel-empty {
      font-style: italic;
      opacity: 0.8;
    }

    .nuclide-panel-footer {
      margin-top: 2px;
      font-size: 10px;
      text-align: center;
      opacity: 0.7;
    }

    #cv {
      display: block;
      width: 100%;
      /* scales down on small screens */
      height: auto;
      /* keeps aspect ratio */
      border: 1px solid #1e90ff;
    }

    .control-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      /* center horizontally */
      justify-content: center;
      padding: 10px 12px;
      background: var(--control-bg);
      border-bottom: 1px solid #cccccc;
      text-align: center;
    }

    .control-panel>div {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      justify-content: center;
      align-items: center;
    }

    .control-panel .pos1 {
      margin-right: 0;
      white-space: nowrap;
      position: static;
    }


    .control-panel input[type="number"] {
      margin-left: 6px;
      padding: 2px 4px;
      width: 90px;
      height: 22px;
      text-align: right;
      font-size: 12px;
    }

    button {
      border: none;
      background: #000000;
      color: #ffffff;
      text-align: center;
      width: 180px;
      font-size: 12px;
      font-weight: 700;
      padding: 8px 14px;
      margin: 4px 4px 0 0;
      text-transform: uppercase;
      border-radius: var(--radius);
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.9);
      display: inline-block;
      cursor: pointer;
      transition:
        background var(--transition-fast),
        transform var(--transition-fast),
        box-shadow var(--transition-fast),
        letter-spacing var(--transition-fast),
        color var(--transition-fast);
    }

    button:hover {
      background: #ffffff;
      color: #000000;
      letter-spacing: 1px;
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.25);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.8);
    }

    button.start {
      background: var(--accent);
      color: #000000;
    }

    button.reset {
      background: var(--danger);
    }

    button.nuclides {
      background: var(--yellow);
      color: #000000;
      width: 260px;
    }

    button.show-ideal {
      background: var(--purple);
      width: auto;
    }

    #graph {
      position: relative;
      /* starts centered under canvas */
      margin: 12px auto 0;
      width: 100%;
      max-width: 600px;
      height: 260px;
      border: 1px solid var(--border);
      background: linear-gradient(to right,
          #ffffff,
          rgba(119, 255, 56, 0.25),
          #ffffff);
      z-index: 9;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    #graphheader {
      padding: 4px 8px;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      background: rgba(0, 0, 0, 0.05);
      /* no dragging cursor */
    }

    #graph-cv {
      flex: 1;
      display: block;
      margin: 0 auto;
    }

    #graph .graph-button-wrapper {
      text-align: center;
      padding: 2px 0 4px;
    }

    @media (max-width: 900px) {
      #total {
        max-width: 100%;
        padding: 0 8px 16px;
      }

      #simRow {
        flex-direction: column;
        align-items: stretch;
      }

      #canvas {
        max-width: 100%;
      }

      #nuclidePanel {
        flex: 0 0 auto;
        width: 100%;
      }

      #graph {
        position: static;
        margin: 8px auto 0;
        width: 100%;
      }

      #cv {
        height: 480px;
      }

      button {
        width: auto;
        min-width: 120px;
      }

      .control-panel {
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>

  <h1>Radioactive Decay</h1>

  <div id="total">

    <div id="simRow">
      <div id="canvas">
        <div class="control-panel">
          <div>
            <span class="pos1">
              <input type="number" id="HalfLife" value="10">
              Half life (seconds)
            </span>
            <span class="pos1">
              <input type="number" id="gridX" value="20">
              Grid Size (horizontal)
            </span>
            <span class="pos1">
              <input type="number" id="gridY" value="20">
              Grid Size (vertical)
            </span>
            <span class="pos1">
              <label>
                <input type="checkbox" id="cloudChamber" checked>
                Cloud chamber (show tracks)
              </label>
            </span>
          </div>
          <div>
            <button id="bu2" class="start">Start</button>
            <button id="bu1" class="reset">Reset</button>
            <!-- rename button text if you like -->
            <button id="bu4" class="nuclides">Display Isotopes with Similar Half Life</button>
          </div>
        </div>

        <canvas id="cv" width="960" height="480">
          This browser doesn't support HTML5 canvas!
        </canvas>
      </div>

      <!-- Right-side panel -->
      <aside id="nuclidePanel" aria-label="Isotopes with similar half-life">
        <div class="nuclide-panel-header">Isotopes with Similar Half-Life</div>
        <div class="nuclide-panel-body">
          <div class="nuclide-panel-list">
            <p class="nuclide-panel-empty">
              Click “Display Isotopes with Similar Half Life” to load the list.
            </p>
          </div>
        </div>
        <div class="nuclide-panel-footer">
          Uses the current half-life value (seconds).
        </div>
      </aside>
    </div>


    <div id="graph">
      <div id="graphheader">The Graph</div>
      <canvas id="graph-cv" width="597" height="220">
        This browser doesn't support HTML5 canvas!
      </canvas>
      <div class="graph-button-wrapper">
        <button id="bu3" class="show-ideal">Show Ideal Decay Plot</button>
      </div>
    </div>
  </div>

  <script>
    var colorBackground = "rgba(50,50,50,1)";
    var colorActive = "#ff0000";
    var colorGradActive;
    var colorDecayed = "#000000";
    var colorTime = "#0000ff";

    var showCloudChamber = true;  // controls trail rendering only

    var prevHalfLife = null;   // for palette changes

    var FONT1 = "normal normal bold 12px sans-serif";
    var halfLife = 20;
    var AtomTotal = 400;
    var xAtoms = 20;
    var yAtoms = 20;
    var atomRadius = 5;
    var graphXPos = 50, graphYPos = 0;
    var graphXIncrement = 40;
    var graphYIncrement = 100;
    var textXPos = 10, textYPos = 20;
    var graphXLength = 420;
    var graphTotalHalfLives = Math.floor(graphXLength / graphXIncrement);
    var atomXPos = 50;
    var atomYPos = 30;
    var timeText = "None.";
    var timeElapsed = 0;
    var spacing = 15;
    var graphScale = 1.2;

    var graphChart = null;   // Chart.js instance

    var canvas, ctx, graphCanvas, graphCtx;
    var bu1, bu2, bu3;
    var on;
    var t0;
    var timer;
    var timeVariable;
    var timeDecay;
    var decayed;
    var number;
    var xyDiagram;

    var text01 = "Reset";
    var text02 = ["Start", "Pause", "Resume"];
    var text03 = "Show Ideal Decay Plot";

    var text04 = "Half Lives:";
    var text05 = "Not yet decayed:";
    var text06 = "Already decayed:";
    var text07 = ["nuclei", "nucleus", "nuclei", "nuclei"];
    var text08 = "Actual time elapsed:";
    var text09 = ["milliseconds", "seconds", "minutes", "hours", "days", "weeks", "months", "years"];

    var decimalSeparator = ".";
    var symbolHalfLife = "T";
    var symbolQuotient = "N/N_0";

    var decayRunning = false;   // controls radioactive decay only
    var loopRunning = false;   // controls whether RAF loop is active
    var rafId = null;
    var lastNow = 0;

    var particles = [];
    var animFrameId = null;

    function getNucleusPosition(i) {
      return {
        x: atomXPos + spacing * (i % xAtoms),
        y: atomYPos + spacing * Math.floor(i / xAtoms)
      };
    }

    const ACCENT_RGBA = "rgba(0,218,200,1)";

    function spawnParticle(x, y) {
      const angle = Math.random() * 2 * Math.PI;
      const speed = 3500 + Math.random() * 300;  // keep your high energy
      const life = 2 + Math.random() * 1;       // uniform fade window
      const length = 550 + Math.random() * 200;   // track length

      const dx = Math.cos(angle), dy = Math.sin(angle);

      // Precompute polyline at fixed spacing -> smooth, uniform density
      const spacing = 6; // px between vertices
      const n = Math.max(2, Math.ceil(length / spacing));
      const points = new Array(n);
      for (let i = 0; i < n; i++) {
        const s = i * spacing;
        points[i] = { x: x + dx * s, y: y + dy * s };
      }

      // Precompute shimmer specks anchored to the line (2 per vertex)
      const theta = Math.atan2(dy, dx) + Math.PI / 2;
      const specks = [];
      for (let i = 0; i < n; i++) {
        const base = points[i];
        const jitter = (Math.random() - 0.5) * 4; // ±2 px band
        const sx = base.x + Math.cos(theta) * jitter;
        const sy = base.y + Math.sin(theta) * jitter;
        const at = i * spacing; // distance along track where speck becomes visible
        specks.push({ x: sx, y: sy, r: 0.9 + Math.random() * 1.1, at });
        specks.push({
          x: sx + (Math.random() - 0.5),
          y: sy + (Math.random() - 0.5), r: 0.7 + Math.random() * 0.9, at
        });
      }

      particles.push({
        x0: x, y0: y, dx, dy,
        speed, length,
        age: 0, life, maxLife: life,
        spacing, points, specks
      });
    }

    function updateParticles(dt) {
      if (dt <= 0) return;

      var w = canvas.width, h = canvas.height, margin = 24;

      for (var i = particles.length - 1; i >= 0; i--) {
        var p = particles[i];
        p.age += dt;
        p.life -= dt;

        if (p.life <= 0) { particles.splice(i, 1); continue; }

        // current tip position along the ray
        var tipLen = Math.min(p.speed * p.age, p.length);
        var tx = p.x0 + p.dx * tipLen;
        var ty = p.y0 + p.dy * tipLen;

        // If the track is complete OR the head is well off-screen, drop it
        if (tipLen >= p.length || tx < -margin || tx > w + margin || ty < -margin || ty > h + margin) {
          particles.splice(i, 1);
        }
      }
    }

    function prand(seed) {
      var x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    function renderParticles() {
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        var lifeFactor = p.life / p.maxLife;
        if (lifeFactor <= 0) continue;

        // Visible portion of the ray at this time
        var currentLen = Math.min(p.speed * p.age, p.length);
        if (currentLen <= 0) continue;

        // Uniform fade of the whole track as time passes
        var alphaTrack = Math.max(0, Math.min(1, lifeFactor)) * 0.9;

        if (showCloudChamber) {
          // Densified shimmer along the ray (no history)
          var segments = 100;                     // resolution
          var step = currentLen / segments;
          var perp = Math.atan2(p.dy, p.dx) + Math.PI / 2;

          for (var s = 0; s <= currentLen; s += step) {
            var t = s / (p.length || 1);         // 0..1 along full planned length

            var baseX = p.x0 + p.dx * s;
            var baseY = p.y0 + p.dy * s;

            // Tight perpendicular jitter band → cloud-chamber look
            var seed = i * 997 + Math.floor(t * 977);
            var jitterMag = 1.5 + 2.5 * prand(seed);          // narrow band
            var jitter = (prand(seed + 1) - 0.5) * 2 * jitterMag;

            var cx = baseX + Math.cos(perp) * jitter;
            var cy = baseY + Math.sin(perp) * jitter;

            // A few specks per sample to avoid gaps (uniform alpha)
            var specks = 3;
            for (var k = 0; k < specks; k++) {
              var sSeed = seed + k * 37;
              var r = 1.0 + 1.2 * prand(sSeed + 1);

              ctx.beginPath();
              ctx.fillStyle = "rgba(0,218,200," + alphaTrack + ")";
              ctx.arc(
                cx + (prand(sSeed + 2) - 0.5) * 0.9,
                cy + (prand(sSeed + 3) - 0.5) * 0.9,
                r,
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }

        // Bright head at current tip (always visible)
        var tipX = p.x0 + p.dx * currentLen;
        var tipY = p.y0 + p.dy * currentLen;

        ctx.beginPath();
        ctx.fillStyle = "rgba(255,255,255," + alphaTrack + ")";
        ctx.arc(tipX, tipY, 2.6, 0, 2 * Math.PI);
        ctx.fill();
      }
    }


    function segmentOffscreen(x1, y1, x2, y2, m, W, H) {
      const left = Math.max(x1, x2) < -m;
      const right = Math.min(x1, x2) > W + m;
      const above = Math.max(y1, y2) < -m;
      const below = Math.min(y1, y2) > H + m;
      return left || right || above || below;
    }

    function renderAtomsAndParticles() {
      ctx.fillStyle = colorBackground;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = FONT1;

      for (var i = 0; i < AtomTotal; i++) {
        var c = decayed[i] ? colorDecayed : colorActive;
        drawNucleus(i, c);
      }

      renderParticles();
    }

    function getElement(id, text) {
      var e = document.getElementById(id);
      if (text) e.innerHTML = text;
      return e;
    }

    function addWheelIncrement(input, step, min, max) {
      if (!input) return;
      input.addEventListener("wheel", function (event) {
        event.preventDefault();

        var value = parseInt(input.value, 10);
        if (!Number.isFinite(value)) value = min;

        if (event.deltaY < 0) {
          value += step;              // scroll up -> increase
        } else if (event.deltaY > 0) {
          value -= step;              // scroll down -> decrease
        }

        if (value < min) value = min;
        if (max && value > max) value = max;

        input.value = value;

        // Rebuild atoms and graph with new grid
        reactionReset();
      }, { passive: false });
    }


    function start() {
      canvas = getElement("cv");
      ctx = canvas.getContext("2d");

      bu1 = getElement("bu1", text01);
      bu2 = getElement("bu2");
      bu3 = getElement("bu3", text03);

      setButton2State(0);

      // wheel on grid inputs
      addWheelIncrement(document.getElementById("gridX"), 1, 1, 300);
      addWheelIncrement(document.getElementById("gridY"), 1, 1, 300);

      // Create the Chart.js graph
      initGraphChart();

      reset();
      paintAtoms();

      bu1.onclick = reactionReset;
      bu2.onclick = reactionStart;
      bu3.onclick = reactionDiagram;

      var cc = getElement("cloudChamber");
      if (cc) {
        showCloudChamber = cc.checked;
        cc.addEventListener("change", function () {
          showCloudChamber = cc.checked;
          // immediate visual refresh
          renderAtomsAndParticles();
        });
      }

      // Wire isotope button to the side panel (not a modal)
      var nuclideButton = getElement("bu4");
      if (nuclideButton) {
        nuclideButton.addEventListener("click", updateNuclidePanel);
      }
    }

    function initGraphChart() {
      var gCanvas = document.getElementById("graph-cv");
      if (!gCanvas || typeof Chart === "undefined") return;

      graphChart = new Chart(gCanvas, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Actual decay (N/N₀)",
              data: [],            // filled by savePoint()
              showLine: false,
              pointRadius: 4
            },
            {
              label: "Ideal decay",
              data: [],            // filled on first button click
              type: "line",
              showLine: true,
              pointRadius: 0,
              borderWidth: 2,
              borderDash: [4, 3],
              hidden: true         // start hidden
            }
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time (half-lives, T)" },
              min: 0,
              max: graphTotalHalfLives
            },
            y: {
              type: "linear",
              title: { display: true, text: "Fraction remaining (N/N₀)" },
              min: 0,
              max: 1
            }
          },
          plugins: {
            legend: { position: "top" }
          }
        }
      });
    }

    function setButton2State(st) {
      bu2.state = st;
      bu2.innerHTML = text02[st];
      bu2.classList.toggle("start", st === 0 || st === 2);
    }

    function switchButton2() {
      var st = bu2.state;
      if (st === 0) st = 1;
      else st = 3 - st;
      setButton2State(st);
    }

    function reactionReset() {
      setButton2State(0);
      decayRunning = false;
      stopLoop();
      reset();
      paintAtoms();
    }


    function reactionStart() {
      // toggle button state: 0->1 (start), 1->2 (pause), 2->1 (resume)
      switchButton2();

      if (bu2.state === 1) {          // Start/Resume
        decayRunning = true;
        ensureLoop();                 // make sure RAF is running
      } else if (bu2.state === 2) {   // Pause
        decayRunning = false;         // stop advancing decay clock
        savePoint();                  // keep your “pause point” behavior
        ensureLoop();                 // keep loop alive to drain particles
      }
    }

    function ensureLoop() {
      if (!loopRunning) {
        loopRunning = true;
        lastNow = performance.now();
        rafId = requestAnimationFrame(loopStep);
      }
    }

    function stopLoop() {
      loopRunning = false;
      if (rafId != null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    }

    function loopStep(now) {
      if (!loopRunning) return;

      var dt = (now - lastNow) / 1000;
      lastNow = now;
      if (dt < 0) dt = 0;
      if (dt > 0.1) dt = 0.1;   // clamp tab-jump spikes

      paintSimulation(dt);      // advance particles every frame; decay only if running

      // Auto-stop when nothing to animate
      if (!decayRunning && particles.length === 0) {
        stopLoop();
        return;
      }
      rafId = requestAnimationFrame(loopStep);
    }

    function reactionDiagram() {
      if (!graphChart) return;

      var idealDataset = graphChart.data.datasets[1];

      // Populate ideal decay if empty
      if (!idealDataset.data || idealDataset.data.length === 0) {
        var pts = [];
        for (var x = 0; x <= graphTotalHalfLives; x += 0.05) {
          pts.push({ x: x, y: Math.pow(2, -x) });
        }
        idealDataset.data = pts;
      }

      // Toggle visibility
      idealDataset.hidden = !idealDataset.hidden;
      bu3.textContent = idealDataset.hidden
        ? "Show Ideal Decay Plot"
        : "Hide Ideal Decay Plot";

      graphChart.update();
    }

    function animationStep(now) {
      if (!on) return;

      var dt = (now - t0) / 1000;  // ms -> s
      t0 = now;

      // Clamp dt to avoid jumps if tab was inactive
      if (dt < 0) dt = 0;
      if (dt > 0.1) dt = 0.1;

      paintSimulation(dt);
      animFrameId = requestAnimationFrame(animationStep);
    }

    function savePoint() {
      if (!graphChart) return;

      // x-axis: time in units of half-life (T)
      var tHalfLives = halfLife > 0 ? timeVariable / halfLife : 0;
      if (tHalfLives < 0) tHalfLives = 0;
      if (tHalfLives > graphTotalHalfLives) return;

      // y-axis: fraction remaining N/N0
      var frac = AtomTotal > 0 ? number / AtomTotal : 0;

      graphChart.data.datasets[0].data.push({ x: tHalfLives, y: frac });
      graphChart.update();
    }

    function setRandomPalette() {
      // base hue 0–359
      var baseHue = Math.floor(Math.random() * 360);

      // active: bright
      var activeHue = baseHue;
      // decayed: opposite hue, darker
      var decayedHue = (baseHue + 180) % 360;

      colorActive = "hsl(" + activeHue + ", 90%, 55%)";
      colorDecayed = "hsl(" + decayedHue + ", 90%, 30%)";
    }

    function reset() {
      var halfLifeInput = parseFloat(document.getElementById("HalfLife").value);
      var xInput = parseInt(document.getElementById("gridX").value, 10);
      var yInput = parseInt(document.getElementById("gridY").value, 10);

      var newHalfLife = (isFinite(halfLifeInput) && halfLifeInput > 0) ? halfLifeInput : 10;
      halfLife = newHalfLife;

      xAtoms = (isFinite(xInput) && xInput > 0) ? xInput : 20;
      yAtoms = (isFinite(yInput) && yInput > 0) ? yInput : 20;

      // Change colors on first load or whenever half-life is changed
      if (prevHalfLife === null || newHalfLife !== prevHalfLife) {
        setRandomPalette();
        prevHalfLife = newHalfLife;
      }

      AtomTotal = xAtoms * yAtoms;

      atomXPos = canvas.width / 2 - (xAtoms - 1) * spacing / 2;
      graphYPos = yAtoms * 8 - 10;
      textYPos = 30;

      var randNr;
      var f = -halfLife / Math.LN2;

      on = false;
      timeVariable = 0;
      timeDecay = new Array(AtomTotal);
      decayed = new Array(AtomTotal);
      number = AtomTotal;
      particles = [];

      for (var i = 0; i < AtomTotal; i++) {
        do {
          randNr = Math.random();
        } while (randNr === 0 || randNr === 1);
        timeDecay[i] = f * Math.log(randNr);
        decayed[i] = false;
      }

      if (yAtoms * spacing > canvas.height - 50) {
        canvas.height = 100 + spacing * yAtoms;
      }

      // Reset the Chart.js data
      if (graphChart) {
        graphChart.data.datasets[0].data = [];  // actual
        // leave ideal dataset as-is; user toggles it
        graphChart.update();
      }

      // Add initial point at t = 0, N/N0 = 1
      savePoint();
    }



    function newPath() {
      ctx.beginPath();
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1;
    }

    function line(x1, y1, x2, y2, c) {
      graphCtx.beginPath();
      if (c) graphCtx.strokeStyle = c;
      graphCtx.moveTo(x1, y1);
      graphCtx.lineTo(x2, y2);
      graphCtx.stroke();
      graphCtx.closePath();
    }

    function arrow(x1, y1, x2, y2, w) {
      graphCtx.strokeStyle = "black";
      graphCtx.fillStyle = "black";
      if (!w) w = 1;
      var dx = x2 - x1, dy = y2 - y1;
      var length = Math.sqrt(dx * dx + dy * dy);
      if (length === 0) return;
      dx /= length; dy /= length;
      var s = 2.5 * w + 7.5;
      var xSp = x2 - s * dx, ySp = y2 - s * dy;
      var h = 0.5 * w + 3.5;
      var xSp1 = xSp - h * dy, ySp1 = ySp + h * dx;
      var xSp2 = xSp + h * dy, ySp2 = ySp - h * dx;
      xSp = x2 - 0.6 * s * dx; ySp = y2 - 0.6 * s * dy;

      graphCtx.beginPath();
      graphCtx.lineWidth = w;
      graphCtx.moveTo(x1, y1);
      if (length < 5) graphCtx.lineTo(x2, y2);
      else graphCtx.lineTo(xSp, ySp);
      graphCtx.stroke();

      if (length < 5) return;
      graphCtx.beginPath();
      graphCtx.lineWidth = 1;
      graphCtx.moveTo(xSp, ySp);
      graphCtx.lineTo(xSp1, ySp1);
      graphCtx.lineTo(x2, y2);
      graphCtx.lineTo(xSp2, ySp2);
      graphCtx.closePath();
      graphCtx.fill();
    }

    function circle(x, y, r, c) {
      if (c) ctx.fillStyle = c;
      ctx.strokeStyle = "black";
      newPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI, true);
      ctx.fill();
      newPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI, true);
      ctx.stroke();
    }

    function writePercent(s, x, y) {
      s = s.replace(".", decimalSeparator);
      write(s, x - 17, y, "right");
      write("%", x - 15, y, "left");
    }

    function writeTextIndex(s, x, y) {
      var s1 = s;
      var i = s1.indexOf("_");
      if (i >= 0) s1 = s.substring(0, i);
      var s2 = "";
      if (i >= 0) s2 = s.substring(i + 1);
      var l1 = graphCtx.measureText(s1).width;
      write(s1, x, y, "left");
      if (i >= 0) write(s2, x + l1, y + 5);
    }

    function drawGraph() {
      graphCanvas = getElement("graph-cv");
      graphXPos = 50;
      graphYPos = 150;

      graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
      graphCtx.beginPath();
      graphCtx.textAlign = "center";
      graphCtx.strokeStyle = "black";

      arrow(graphXPos - 10, graphYPos, graphXPos + graphXLength * graphScale, graphYPos);
      graphCtx.fillText("Time", graphXPos + 215, graphYPos + 33);

      for (var i = 1; i <= graphTotalHalfLives; i++) {
        var xT = graphXPos + i * graphXIncrement;
        line(xT, graphYPos + 3, xT, graphYPos - 3);
        var s = (i > 1 ? "" + i + "T" : "T");
        graphCtx.fillText(s, xT, graphYPos + 15);
      }

      arrow(graphXPos, graphYPos + 10, graphXPos, graphYPos - 125 * graphScale);

      for (var k = 0; k <= 4; k++) {
        var y0 = graphYPos - graphYIncrement * Math.pow(2, -k);
        line(graphXPos - 3, y0, graphXPos + 3, y0, "black");
      }

      writeTextIndex(symbolQuotient, graphXPos - 30, graphYPos - 115);
      writePercent("100", graphXPos, graphYPos - 95);
      writePercent("50", graphXPos, graphYPos - 45);
      writePercent("25", graphXPos, graphYPos - 20);
      writePercent("12.5", graphXPos, graphYPos - 8);
    }

    function drawNucleus(i, c) {
      var pos = getNucleusPosition(i);
      var x = pos.x;
      var y = pos.y;

      if (c === colorDecayed) {
        // decayed: black square
        ctx.fillStyle = colorDecayed;
        ctx.fillRect(x - atomRadius, y - atomRadius, atomRadius * 2, atomRadius * 2);
      } else {
        // active: solid red circle
        ctx.fillStyle = colorActive;
        ctx.beginPath();
        ctx.strokeStyle = "black";
        ctx.arc(x, y, atomRadius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }
    }

    function paintAtoms() {
      renderAtomsAndParticles();
    }

    function drawDecayLine() {
      graphCtx.beginPath();
      graphCtx.strokeStyle = "blue";

      var xx = graphXPos;
      var yy = graphYPos - graphYIncrement;
      graphCtx.moveTo(xx, yy);

      while (xx < graphXPos + 300) {
        xx++;
        yy = graphYPos - graphYIncrement *
          Math.exp(-(xx - graphXPos) / graphXIncrement * Math.LN2);
        graphCtx.lineTo(xx, yy);
      }
      graphCtx.stroke();
      graphCtx.closePath();
      graphCtx.strokeStyle = "black";
    }

    function write(s, x, y, a) {
      if (a) graphCtx.textAlign = a;
      graphCtx.fillText(s, x, y);
    }

    function textNuclei(n) {
      if (n === 0) return text07[0];
      if (n === 1) return text07[1];
      if (n === 2) return text07[2];
      return text07[3];
    }

    function writeValues() {
      graphCtx.fillStyle = colorBackground;
      graphCtx.fillRect(textXPos, textYPos, 280, 77);

      var x1 = textXPos + 190;
      var x2 = textXPos + 200;
      var y1 = textYPos + 10;
      var y2 = textYPos + 30;
      var y3 = textYPos + 50;
      var y4 = textYPos + 70;

      graphCtx.fillStyle = colorTime;

      write(text04, textXPos, y1, "left");
      var s = Number(timeVariable / halfLife).toFixed(2);
      var s1 = timeVariable;
      s = s.replace(".", decimalSeparator);
      write(s, x1, y1, "right");
      write(symbolHalfLife, x2, y1, "left");

      graphCtx.fillStyle = colorActive;
      write(text05, textXPos, y2);
      write(String(number), x1, y2, "right");
      write(textNuclei(number), x2, y2, "left");

      graphCtx.fillStyle = colorDecayed;
      write(text06, textXPos, y3);
      var nd = AtomTotal - number;
      write(String(nd), x1, y3, "right");
      write(textNuclei(nd), x2, y3, "left");

      setTimeText(s1);
      graphCtx.fillStyle = colorTime;
      write(text08, textXPos, y4);
      var sElapsed = Number(timeElapsed).toFixed(2)
        .replace(".", decimalSeparator);
      write(sElapsed, x1, y4, "right");
      write(timeText, x2, y4, "left");
      graphCtx.fillStyle = "black";
    }

    function setTimeText(timeNum) {
      if (timeNum < 1) {
        timeText = text09[0];
        timeElapsed = timeNum;
      } else if (timeNum < 60) {
        timeText = text09[1];
        timeElapsed = timeNum;
      } else if (timeNum < 3600) {
        timeText = text09[2];
        timeElapsed = timeNum / 60;
      } else if (timeNum < 86400) {
        timeText = text09[3];
        timeElapsed = timeNum / 3600;
      } else if (timeNum < 604800) {
        timeText = text09[4];
        timeElapsed = timeNum / 86400;
      } else if (timeNum <= 2449440) {
        timeText = text09[5];
        timeElapsed = timeNum / 604800;
      } else if (timeNum <= 31536000) {
        timeText = text09[6];
        timeElapsed = timeNum / 2449440;
      } else {
        timeText = text09[7];
        timeElapsed = timeNum / 31536000;
      }
    }

    function paintSimulation(dt) {
      dt = dt || 0;

      // Advance decay clock only when not paused
      if (decayRunning && dt > 0) {
        timeVariable += dt;
      }

      // Spawn decays only when decay is running
      if (decayRunning) {
        for (var i = 0; i < AtomTotal; i++) {
          if (decayed[i]) continue;
          if (timeVariable < timeDecay[i]) continue;
          decayed[i] = true;
          number--;
          var pos = getNucleusPosition(i);
          spawnParticle(pos.x, pos.y);
        }
      }

      // Particles always update & fade, even when paused
      updateParticles(dt);

      // Redraw atoms + particle effects
      renderAtomsAndParticles();
      // Graph is updated only when we explicitly save points via savePoint()
    }

    document.addEventListener("DOMContentLoaded", start, false);

    // Isotope side panel (no modal)
    // Isotope side panel (no modal)
    function updateNuclidePanel() {
      var panel = document.getElementById("nuclidePanel");
      if (!panel) return;

      var listEl = panel.querySelector(".nuclide-panel-list");
      if (!listEl) return;

      var input = document.getElementById("HalfLife");
      var halfLifeVal = parseFloat(input && input.value);

      if (!Number.isFinite(halfLifeVal) || halfLifeVal <= 0) {
        listEl.innerHTML =
          '<p class="nuclide-panel-empty">Enter a positive half-life to see matching isotopes.</p>';
        return;
      }

      var matches = [];
      if (typeof nuclides === "object" && Array.isArray(nuclides.nuclides)) {
        var logTarget = Math.log(halfLifeVal);

        for (var i = 0; i < nuclides.nuclides.length; i++) {
          var nuc = nuclides.nuclides[i];
          var nHL = nuc["half-life"];
          if (!nHL || nHL <= 0) continue;

          // Within ±1 order of magnitude in log-space
          if (Math.abs(Math.log(nHL) - logTarget) <= 1) {
            matches.push(nuc);
          }
        }

        // Sort by half-life for readability
        matches.sort(function (a, b) {
          return a["half-life"] - b["half-life"];
        });
      }

      if (!matches.length) {
        listEl.innerHTML =
          '<p class="nuclide-panel-empty">No isotopes in the dataset within one order of magnitude.</p>';
        return;
      }

      var html = "";
      for (var j = 0; j < matches.length; j++) {
        var n = matches[j];
        html +=
          '<div class="nuclide-panel-row">' +
          '<span class="nuclide-panel-name">' + n.name + '</span>' +
          '<span class="nuclide-panel-hl">' +
          numberWithCommas(n["half-life"]) + ' s</span>' +
          '</div>';
      }
      listEl.innerHTML = html;
    }

    // Wire the button to update the side panel
    var bu4 = document.getElementById("bu4");
    if (bu4) {
      bu4.addEventListener("click", updateNuclidePanel);
    }

    function numberWithCommas(x) {
      x = Number(x);
      if (!Number.isFinite(x)) return "";
      if (x >= 1) {
        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      if (x > 0 && x < 1) {
        var parts = x.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, " ");
        return parts.join(".");
      }
      return x.toString();
    }
  </script>
</body>

</html>